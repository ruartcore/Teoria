/*
Я считаю, что этот код плохой потому что

#       Название метода 'test' похоже на название метода в классе RegExp, который используется для тестирования регулярных выражений,
    такой код может запутать разработчика если он будет использовать регулярные выражения.

#       Главный класс имеет узкую специализацию, используются только переменные класса 'a', 'b', следовательно чего класс не масштабируемый 
    и у каждого наследуемого класса могут быть проблемы из за перегрузки методов 'set' & 'get' => Весь код можно уместить в один класс, который
    не нуждается в наследовании.

#       Для такой задачи я бы использовал отдельные классы  для получения данных. Класс BaseClass хранит в себе описание базового метода 'test',
    второй класс 'Two' хранит ReleaseA = new ReleaseA(); / ReleaseB = new ReleaseB(); , третий класс наследует BaseClass и использует методы 'Two'
    test(a,b){
        return new Two().ReleaseA(a,b);
    }

    Короче говоря вынести реализации метода 'test' в отдельные элементы
*/

// Реализуйте класс
class BaseClass {
  set a(val) {
    this._a = -val;
  };
  set b(val) {
    this._b = -val;
  };
  get a() {
    return this._a;
  };
  get b() {
    return this._b;
  };
}

/* Код ниже не трогаем */
class MyClass extends BaseClass {
    test(a, b) {
        this.a = a;
        this.b = b;

        return 100 - this.a + this.b;
    }
}

const m = new MyClass();

console.log(m.test(50, 40) === 110); // true
console.log(m.test(10, 90) === 20);  // true